#!/usr/bin/env node

// Testing loop performance for the most used array methods in JavaScript
console.time('Test Execution Duration');


const arraySize = parseInt(1e5); // 100000
const testArray = Array(arraySize);

// Pre-allocating memory for the map function returned array to avoid memory realloacation per
// iteration (as repeated `arrayMapCopy.push(el)` calls would do). We are declaring it as a global
// variable in order to not impact the perfomance measure of the loopMap function (line 196).
let arrayMapCopy = Array(arraySize);

const testResultsArray = [];
const iterations = 1500;
for (let i = 0; i < iterations; i++)
  // we can use push here, once we are just aggregating results for 
  // tests that were already executed in their isolated scopes
  testResultsArray.push(generateTestResults(testArray));

// Average result of each operation after 1500 different tests (sorry, DRY)
const forEachResult = Number(( // .forEach
  testResultsArray.reduce(
    (acc, result) => acc + result.forEach, 0) / testResultsArray.length
).toFixed(5));
const forLoopResult = Number(( // For Loop
  testResultsArray.reduce(
    (acc, result) => acc + result.forLoop, 0)/ testResultsArray.length
).toFixed(5));
const mapMethodResult = Number(( // .map
  testResultsArray.reduce(
    (acc, result) => acc + result.mapMethod, 0) / testResultsArray.length
).toFixed(5));
const mapLoopResult = Number(( // Map Loop
  testResultsArray.reduce(
    (acc, result) => acc + result.mapLoop, 0) / testResultsArray.length
).toFixed(5));
const findMethodResult = Number(( // .find
  testResultsArray.reduce(
    (acc, result) => acc + result.findMethod, 0) / testResultsArray.length
).toFixed(5));
const findLoopResult = Number(( // Find Loop
  testResultsArray.reduce(
    (acc, result) => acc + result.findLoop, 0) / testResultsArray.length
).toFixed(5));
const findIndexMethodResult = Number(( // .findIndex
  testResultsArray.reduce(
    (acc, result) => acc + result.findIndexMethod, 0) / testResultsArray.length
).toFixed(5));
const findIndexLoopResult = Number(( // FindIndex Loop
  testResultsArray.reduce(
    (acc, result) => acc + result.findIndexLoop, 0) / testResultsArray.length
).toFixed(5));
const filterMethodResult = Number(( // .filter
  testResultsArray.reduce(
    (acc, result) => acc + result.filterMethod, 0) / testResultsArray.length
).toFixed(5));
const filterLoopResult = Number(( // Filter Loop
  testResultsArray.reduce(
    (acc, result) => acc + result.filterLoop, 0) / testResultsArray.length
).toFixed(5));
const reduceMethodResult = Number(( // .reduce
  testResultsArray.reduce(
    (acc, result) => acc + result.reduceMethod, 0) / testResultsArray.length
).toFixed(5));
const reduceLoopResult = Number(( // Reduce Loop
  testResultsArray.reduce(
    (acc, result) => acc + result.reduceLoop, 0) / testResultsArray.length
).toFixed(5));

console.log(`Average Results for ${iterations} test samples from arrays with ${arraySize} random numbers from 1 to 10000.`);
console.table([
  { 
    Operation: 'For', 'Method (ms)': forEachResult,
    'Loop (ms)': forLoopResult,
    'Difference (loop - method)': Number((forLoopResult - forEachResult).toFixed(5))
  },
  { 
    Operation: 'Map', 'Method (ms)': mapMethodResult,
    'Loop (ms)': mapLoopResult,
    'Difference (loop - method)': Number((mapLoopResult - mapMethodResult).toFixed(5))
  },
  { 
    Operation: 'Find', 'Method (ms)': findMethodResult,
    'Loop (ms)': findLoopResult,
    'Difference (loop - method)': Number((findLoopResult - findMethodResult).toFixed(5))
  },
  { 
    Operation: 'FindIndex', 'Method (ms)': findIndexMethodResult,
    'Loop (ms)': findIndexLoopResult,
    'Difference (loop - method)': Number((findIndexLoopResult - findIndexMethodResult).toFixed(5))
  },
  { 
    Operation: 'Filter', 'Method (ms)': filterMethodResult,
    'Loop (ms)': filterLoopResult,
    'Difference (loop - method)': Number((filterLoopResult - filterMethodResult).toFixed(5))
  },
  { 
    Operation: 'Reduce', 'Method (ms)': reduceMethodResult,
    'Loop (ms)': reduceLoopResult,
    'Difference (loop - method)': Number((reduceLoopResult - reduceMethodResult).toFixed(5))
  }
]);

console.timeEnd('Test Execution Duration');

function generateTestResults(testArray) {
  // For x ForEach
  const forEachStart = Date.now();
  testArray.forEach((_, i) => {
    testArray[i] = Math.ceil(Math.random() * 10000);
  });
  const forEachEnd = Date.now();
  const forEach = forEachEnd - forEachStart;

  const forLoopStart = Date.now();
  for (let i = 0; i < testArray.length; i++) {
    testArray[i] = Math.ceil(Math.random() * 10000);
  }
  const forLoopEnd = Date.now();
  const forLoop = forLoopEnd - forLoopStart;

  // Map
  const mapMethodStart = Date.now();
  testArray.map(v => v % 2);
  const mapMethodEnd = Date.now();
  const mapMethod = mapMethodEnd - mapMethodStart;

  const mapLoopStart = Date.now();
  loopMap(testArray, '% 2');
  const mapLoopEnd = Date.now();
  const mapLoop = mapLoopEnd - mapLoopStart;

  // Find
  const findMethodStart = Date.now();
  testArray.find(v => v === 255);
  const findMethodEnd = Date.now();
  const findMethod = findMethodEnd - findMethodStart;

  const findLoopStart = Date.now();
  loopFind(testArray, 255);
  const findLoopEnd = Date.now();
  const findLoop = findLoopEnd - findLoopStart;

  // FindIndex - redundant once we've tested Find, why not though?
  const findIndexMethodStart = Date.now();
  testArray.findIndex(v => v === 255);
  const findIndexMethodEnd = Date.now();
  const findIndexMethod = findIndexMethodEnd - findIndexMethodStart;

  const findIndexLoopStart = Date.now();
  loopFindIndex(testArray, 255);
  const findIndexLoopEnd = Date.now();
  const findIndexLoop = findIndexLoopEnd - findIndexLoopStart;

  // Filter
  const filterMethodStart = Date.now();
  testArray.filter(v => v % 2 === 0);
  const filterMethodEnd = Date.now();
  const filterMethod = filterMethodEnd - filterMethodStart;

  const filterLoopStart = Date.now();
  loopFilter(testArray, '% 2 === 0');
  const filterLoopEnd = Date.now();
  const filterLoop = filterLoopEnd - filterLoopStart;

  // Reduce
  const reduceMethodStart = Date.now();
  testArray.reduce((acc, el) => acc + el, 0);
  const reduceMethodEnd = Date.now();
  const reduceMethod = reduceMethodEnd - reduceMethodStart;

  const reduceLoopStart = Date.now();
  loopReduce(testArray, (acc, el) => acc + el, 0);
  const reduceLoopEnd = Date.now();
  const reduceLoop = reduceLoopEnd - reduceLoopStart;

  return {
    forEach,
    forLoop,
    mapMethod,
    mapLoop,
    findMethod, 
    findLoop,
    findIndexMethod,
    findIndexLoop,
    filterMethod,
    filterLoop,
    reduceMethod,
    reduceLoop
  }
}

// Loop alternatives for comparison
function loopMap(array, operation) {
  for (let [i, element] of array.entries()) {
    arrayMapCopy[i] = eval(`${element} ${operation}`);
  }

  return arrayMapCopy;
}

function loopFind(array, value) {
  for (let currentValue of array) {
    if (currentValue === value) return value;
  }
  return undefined;
}

function loopFindIndex(array, value) {
  for (let [i, currentValue] of array.entries()) {
    if (currentValue === value) return i;
  }
  return -1;
}

function loopFilter(array, condition) {
  const filteredArray = [];
  for (let value of array) {
    // Only supports numbers, if you want to support also strings, you need something like the logic bellow
    // const condition = typeof value === 'string' ? `'${value}' ${condition}` : `${value} ${condition}`;
    // anyways, is not a perfect filter for things such as objects, but for comparison, it works in this example.
    if (eval(`${value} ${condition}`)) {
      filteredArray.push(value);
    }
  }
  return filteredArray;
}

function loopReduce(array, fn, acc) {
  for (let element of array) {
    acc = fn(acc, element);
  }
  return acc;
}
